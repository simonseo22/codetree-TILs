// 반지름이 1~n순으로 커지는 원판, 원판마다 m개의 정수 (12시 방향부터 시계방향)
// *원판을 독립적으로 회전 종류 x, 방향 d(시계, 반시계), 회전칸수 k
// 원판이 x의 배수인 경우 회전, d는 시계, 반시계, k는 돌리는칸
// 반시계방향인경우 m번째 정수를 m-k번째 정수 위치로
// *회전후 인전하면서 숫자가 같은 경우 수를 제거
// (r, 1)은 (r, 2)와 (r, m)과 인접 
// (r, m)은 (r, m-1)과 (r, 1)과 인전 // m번째는 1번째와 인접
// (r, j)는 (r, j-1), (r, j+1)과 인접 
// (r, j)는 (r-1, j), (r+1, j)와 인접 
// * 지워지는 수가 없는경우 평균(소숫점 버림)을 구해서 정규화
// 정규화 ( 평균보다 크면 -1, 작으면 +1, 같은수는 그대로, )
// 남은 수가 없는 경우 정규화 X
// q번 진행후 게임판의 남아있는 수의 총합

// *입력
// 1) 원판의 개수 n, 원판내 숫자 m, 회전 횟수 q
// *2~n,m~50 , 1~q~50
// 2~n+1) 원판에 적흰수 (r,j) 1~1,000
// n+2~ n+2 + q-1 ) 회전 정보 원판종류 x 방향 d 칸수 k
// *2~x~n, d(0 : 시계, 1 : 반시계), 1~k~m

// *출력
// q번 회전후 남아있는 수의 합

#include <iostream>

int main() {
    // 여기에 코드를 작성해주세요.
    return 0;
}