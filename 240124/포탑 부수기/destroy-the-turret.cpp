// n*m 격자, 모든 위치에 포탑 존재
// 각 포탑 공격력 존재 ( 상황에 따라 늘어나거나 줄어듬)
// 공격력이 0이하가 되면 포탑은 부서져 더이상 공격할수 없음
// 최초에 공격력이 0인포탑(부서진포탑)이 존재하기도함
// 1개의 턴은 4가지 액션을 수행, K번 반복, 
// 부서지지 않는 포탑이 1개가 되면 즉시중지
// 1. 공격자 선정
// - 부서지지 않는 포탑중 가장 약한 포탑이 공격자
// - 공격자가 되면 핸디캡으로 N+M만큼 공경력 증가
// - 가장약한 포탑 선정 기준
// 1) 공격력이 가장 낮은 포탑이 가장 약한 포탑
// 2) 약한 포탑이 2개 이상 이면 가장 최근에 공격한 포탑
// (모든 포탑은 시점 0에 모두 공격한 경험이 있다고 가정)
// 3) 그러한 포탑이 2개 이상이면 행과 열의 합이 가장 큰 포탑
// 4) 그러한 포탑이 2개 이상이면 열의 값이 가장 큰 포탑
// 2. 공격자의 공격
// - 공격자는 자신을 제외하고 가장 강한 포탑을 공격
// - 가장 강한 포탑 선정 기준
// 1) 공격력이 가장 강한 포탑
// 2) 1)이 2개 이상이면 공격한지 가장 오래된 포탑
// (모든 포탑은 시점 0에 공격 경험이 있다고 가정)
// 3) 2)같은 포탑이 2개 이상이면 행과 열의 합이 가장 작은 포탑
// 4) 3)같은 포탑이 2개 이상이면 열 값이 가장 작은 포탑
// 공격에는 레이저 공격을 먼저 시도하고 그게 안된다면 포탄 공격 실행
// (1) 레이저 공격
// 1) 레이저는 상하좌우 4개의 방향으로 움직일 수 있음
// 2) 부서진 포탑이 있는 위치는 지날수 없음
// 3) 가장자리에 막힌 방향으로 진행하고자 하면 반대편으로 나옴
// - 레이저 공격은 공격자 위치에서 대상 포탑까지 최단 경로로 공격(없다면 포탄공격 실행)
// - 똑같은 길이의 최단 경로가 2개이상이면 우/하/좌/상의 우선 순위대로 먼저 움직인 경로 선택
// - 최단 경로가 정해지면 공격자의 공격력만큼의 피해를 입힘, 입은 피해만큼 공격력 줄어듬
// - 공격대상을 제외한 레이저 경로에 있는 포탑도 공격을 받으며 공격자 공격력의 절반 만큼 받음(공격력/2)
// (2) 포탄 공격
// - 공격 대상에 포탄을 던짐
// - 공격 대상은 공격자 공격력 만큼 피해를 받음
// - 추가적으로 주위 8개 방향 포탑도 피해를 받음,(공격자의 공격력의 절반 만큼 공격력/2)
// - 공격자는 해당 공격에 영향을 받지 않음
// - 가장자리에 포탄이 떨어지면 레이저 이동처럼 추가 피해가 반대 격자에 영향을 미침
// 3. 포탑 부서짐
// - 공격을 받아 공격력이 0이하가 된 포탑은 부서짐
// 4. 포탑정비
// - 공격이 끝났으면 부서지지 않은 포탑중 공격과 무관했던 포탑은 공격력이 1씩 올라감
// - 공격에 무관(공격자도 아니고, 공격력에 피해를 입은 포탑도 아님)
// 전체 과정 종료 후 남아있는 포탑중 가장 강한 포탑의 공격력 출력

// *입력
// 1) n,m(4~10),k(1~1,000)
// 2~(n)) n*m격자에 대한 정보, 최초에 부서지지 않은 포탑은 최소 2개 이상 존재

// 경로를 구해야함


#include <iostream>

int main() {
    // 여기에 코드를 작성해주세요.
    return 0;
}