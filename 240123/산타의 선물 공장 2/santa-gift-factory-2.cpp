// *문제
// 1. 공장 설립
// n개의 벨트 설치, m개의 물건 준비
// m개 선물의 위치가 공백을 사이에 두고 주어짐
// 2. 물건 모두 옮기기
// m_src번째 벨트에 있는 선물들을 모두 m_dst번째 벨트의 선물들로 옮김
// 옮겨진 선물들은 m_dst벨트 앞에 위치
// m_src번째 벨트에 있는 선물이 존재X -> 아무것도 옮기지 않음
// 옮긴 뒤 m_dst번째 벨트에 있는 선물의 개수 출력
// 3. 앞 물건만 교체
// m_src번째 벨트에 있는 가장 앞에 있는 선물과 m_dst번째 벨트의 선물중 가장 앞에 있는 선물을 교체
// 둘중 하나의 벨트에 선물이 아예 존재하지 않다면 교체 X, 해당 벨트로 선물을 옮기기만
// 옮긴 후 m_dst번째 벨트에 있는 선물의 개수 출력
// 4. 물건 나누기
// m_src번째 벨트에 있는 선물의 개수를 n이라고 할때 가장앞에서 floor(n/2)번째 있는 선물을 m_dst앞으로 옮기
// m_src벨트에 선물이 1개 있는 경우 선물을 옮기지 않음
// 옮긴 뒤 m_dst번째 벨트에 있는 선물의 개수 출력
// 5. 선물 정보 얻기
// 선물 번호 p_num이 주어질때 해당 선물의 앞 선물의 번호 a, 뒤선물의 번호 b -> a+2*b출력
// 앞선물이 없는 경우 a = -1, 뒤 선물이 없는 경우 b = -1 로 계산
// 6. 벨트 정보
// 벨트 번호 b_num이 주어질때 맨 앞에 있는 선물의 번호 a, 맨 뒤에 있는 선물의 번호 b
// 해당 벨트에 있는 선물의 개수 c -> a+2b+3c 출력
// 선물이 없는 벨트의 경우 a,b가 -1
// q번에 걸쳐 명령을 순서대로 진행하여 원하는 결과를 출력하는 프로그램

// *입력
// 1) 명령의수 q (1 ~ 100,000)
// 2~(q) ) 명령의 정보
// - *공장 설립 
// - 100 n(벨트개수 2~100,000) m(물건, 1~100,000) B_num1 ~ B_numm, n개 벨트, m개 선물
// - 각물건에 대한 벨트 개수가 입력, 항상 처음입력으로 주어짐, 출력 없음
// - *물건 모두 옮기기
// - 200 m_src m_dst 
// - m_dst 선물의 총 수 출력 m_src와 m_dst는 같지 않음
// - *앞 물건만 교체
// - 300 m_src m_dst
// - m_dst 선물의 총수 출력 m_src와 m_dst는 같지 않음
// - *물건 나누기
// - 400 m_src m_dst
// - m_dst의 선물의 총수 m_src와 m_dst는 같지 않음(해당 명령은 최대 100번까지만 주어짐)
// - *선물 정보 얻기
// - 500 p_num (1~m)
// - 앞선물의 번호 a, 뒤 선물의 번호b a + 2*b출력, 없는경우 각각 -1을 대입
// - *벨트 정보 얻기
// - 600 b_num ( 1~n)
// - 맨 앞에 있는 선물의 번호를a, 맨 뒤에 있는 선물의 번호를 b, 
// - 해당 벨트에 있는 선물의 개수를 c라고 할 때, a + 2*b + 3*c의 값을 출력
// - 없을 경우에는 a, b에 각각 -1을 대입합니다. 이때의 c는 0이

//*출력
// q개 명령에 대한 출력
#include <iostream>

int main() {
    // 여기에 코드를 작성해주세요.
    return 0;
}