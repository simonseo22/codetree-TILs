// *문제
// n*n격자, m명의 사람 1번은 1분~ m번은 m분에 각자 출발해서 편의점으로 이동
// 출발 시간이 되기 전까지 격자 밖에 나와있음, 
// 사람들이 목표로 하는 편의점은 모두 다름
// 아래 3가지 순서로 움직이며 1분소요
// 1) 격자에 있는 사람들 모두 본인이 가고 싶은 방향으로 1칸 움직임
// - 최단거리로 움직이며, 최단거리 방법이 여러가지면 상좌우하 순서로 움직임
// - 최단거리 : 인접한 칸 중 이동가능한 칸으로만 이동해 도달하기 까지 거쳐야하는 칸의 최소수
// 2) 편의점에 도착하면 해당 편의점에 멈춤
// - 이때부터 다른 사람들은 해당 편의점 칸을 지날수 없음
// - 격자에 있는 사람들이 모두 이동한 뒤 해당 칸을 지나갈수 없음에 유의!
// 3) 현재 시간이 t분, t<=m을 만족한다면 
// - t번 사람은 자신이 가고싶은 편의점과 가장 가까이 있는 캠프로 들어감
// - 가장 가까이 있다는 뜻은 1에서 최단거리와 동일
// - 가장 가까이 있는 베이스 캠프가 여러가지인 경우 행이 작은, 행이 같다면 열이 작은
// - t번 사람이 베이스 캠프로 이동하는데는 시간이 소요 X
// - 이때부터 다른 사람들은 해당 베이스 캠프가 있는 칸을 지나갈수 없음
// - t번 사람이 편의점을 향해 움직이기 시작하더라도 해당 베이스 캠프는 앞으로 절대 지나갈수 없음
// - 격자에 있는 사람들이 모두 이동한 뒤 해당 칸을 지나갈수 없음에 유의


// ? 사람이 겹치는 경우 아무런 처리 X
// 같은 편의점에 도달 X (서로 원하는 편의점은 다름)
// 3번에 의해 베이스캠프또한 서로 다름
// 가는길에 베이스 캠프가 있는고 둘이 함께 들어가는경우 ( 모든 이동뒤 불가능이므로 일단은 가능)


// *입력
// 1) 격자 크기 n(2~15), 사람의 수 m(1~ min(n^2,30))
// 2~(n) ) 격자 정보, 각 행에 해당하는 n개의 수가 공백을 사이에 두고
// - 0 : 빈공간, 1 : 베이스 캠프 (m ~ n^2-m)
// (m) ) 각 사람들이 가고자 하는 편의점의 행 x, 열 y의 정보가 공백을 사이에 두고
// - 각사람마다 가고싶은 편의점 위치는 겹치지 않으며, 편의점의 위치와 베이스캠프의 위치도 겹치지 않음

// *출력
// 모든 사람이 편의점에 도착하는 시간
// - 편의점에 도달하지 못하는 경우는 절대 발생하지 않음을 가정
// - 이동중 동일한 칸에 둘이상의 사람이 위치하게 되는 경우 역시 가능
#include <iostream>

int main() {
    // 여기에 코드를 작성해주세요.
    return 0;
}